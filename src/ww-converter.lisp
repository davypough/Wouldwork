;;; Filename:  ww-converter.lisp

;;; Procedures for converting database hashtable lookups from symbols to integers


(in-package :ww)


(defun do-integer-conversion ()
  "Convert all objects to integers & put in idatabases."
  (format t "~&Optimizing lambda expressions and compiling...")
  (associate-objects-with-integers)
  (iter (for (type constants) in-hashtable *types*)
    (iter (for constant in constants)
      (when (or (symbolp constant) (realp constant) (characterp constant))
        (setf (gethash (convert-to-integer (list type constant)) *static-idb*) t))))
  (iter (for (proposition value) in-hashtable *db*)
        (for iproposition = (convert-to-integer proposition))
        (setf (gethash iproposition *idb*) value)
        (setf (gethash iproposition (problem-state.idb *start-state*)) value))
  (iter (for (proposition value) in-hashtable *hdb*)
        (for iproposition = (convert-to-integer proposition))
        (setf (gethash iproposition *hidb*) value)
        (setf (gethash iproposition (problem-state.hidb *start-state*)) value))
  (iter (for (proposition value) in-hashtable *static-db*)
        (for iproposition = (convert-to-integer proposition))
        (setf (gethash iproposition *static-idb*) value))
  (iter (for (proposition value) in-hashtable *hap-db*)
        (for iproposition = (convert-to-integer proposition))
        (setf (gethash iproposition *hap-idb*) value)
        (setf (gethash iproposition (problem-state.hidb *start-state*)) value))
  (iter (for action in *actions*)
        (format t "~&  ~A..." (action.name action))
        (with-slots (pre-defun-name eff-defun-name precondition-lambda effect-lambda) action
          (compile pre-defun-name (subst-int-code precondition-lambda))
          (compile eff-defun-name (subst-int-code effect-lambda))))
  (iter (for fname in (append *query-names* *update-names*))
        (format t "~&  ~A..." fname)
        (compile fname (subst-int-code (symbol-value fname))))
  (iter (for obj in *happening-names*)
        (format t "~&  ~A..." obj)
        (when (get obj :interrupt)  ;ie, there is an :interrupt function
          (setf (get obj :interrupt) (compile nil (subst-int-code (symbol-value obj))))))
  (when (boundp 'goal-fn)
    (format t "~&  ~A..." 'goal-fn)
    (compile 'goal-fn (subst-int-code (symbol-value 'goal-fn))))
  (when (boundp 'constraint-fn)
    (format t "~&  ~A..." 'constraint-fn)
    (compile 'constraint-fn (subst-int-code (symbol-value 'constraint-fn)))))


(defun associate-objects-with-integers ()
  "Build list of all object constants requiring conversion."
  (let (objects)    
    (push 'always-true objects)
    (push 'waiting objects)
    (push nil objects)
    (iter (with flat-codes = (append (alexandria:flatten (when (boundp 'goal-fn)
                                                           (symbol-value 'goal-fn)))
                                     (alexandria:flatten (when (boundp 'constraint-fn)
                                                           (symbol-value 'constraint-fn)))))
          (for item in flat-codes)
          (when (numberp item)
            (collecting item into numbers))
          (finally (alexandria:appendf objects numbers)))
    (iter (for (prop nil) in-hashtable *db*)
          (appending (remove-if-not #'numberp prop) into numbers)
          (finally (alexandria:appendf objects numbers))) 
    (iter (for (prop nil) in-hashtable *static-db*)
          (appending (remove-if-not #'numberp prop) into numbers)
          (finally (alexandria:appendf objects numbers)))
    (alexandria:appendf objects (iter (for (type constants) in-hashtable *types*)
                                      ;(when (symbolp (first constants))
                                        (collecting type)
                                        (appending constants)))
    (alexandria:appendf objects (iter (for (predicate nil) in-hashtable *relations*)
                                      (collecting predicate)))
    (alexandria:appendf objects (iter (for (predicate nil) in-hashtable *static-relations*)
                                      (collecting predicate)))
    (setf objects (delete-duplicates objects))
    (iter (for obj in objects)
          (when (or (listp obj) (vectorp obj))
            (setf *constant-integers* (make-hash-table :test #'equal))  ;redefine if necessary
            (leave)))
    (iter (for obj in objects)
          (for i from 100)
          (setf (gethash obj *constant-integers*) i)
          (setf (gethash i *integer-constants*) obj)
          (finally (setf *last-object-index* i)))))
  

(defun subst-int-code (code-tree)
  (labels ((process-item (item)
             (cond
               ((atom item) item)
               ((not (typep item 'alexandria:proper-list)) item)
               ((and (consp item) (eql (first item) 'gethash)
                     (consp (second item)) (eql (first (second item)) 'list))
                (list (first item)
                      (convert-prop-list (second item))
                      (cond
                        ((equal (third item) '(problem-state.db state))
                         '(problem-state.idb state))
                        ((eql (third item) '*static-db*)
                         '*static-idb*)
                        ((eql (third item) 'idb)
                         'idb)
                        ((equal (third item) '(merge-db-hdb state))
                         '(merge-idb-hidb state))
                        (t (error "Error in subst-int-code: ~A" (third item))))))
               (t (mapcar #'process-item item)))))
    (process-item code-tree)))


(defun convert-to-integer (proposition)
  (iter (for item in proposition)
        (for multiplier in '(1 1000 1000000 1000000000 1000000000000))
        (ut::if-it (gethash item *constant-integers*)
          (summing (* ut::it multiplier))
          (progn (incf *last-object-index*)
                 (when (>= *last-object-index* 1000)
                   (error "Design Limit Error: Total # of actual + derived planning objects > 999"))
                 (setf (gethash item *constant-integers*) *last-object-index*)
                 (setf (gethash *last-object-index* *integer-constants*) item)
                 (summing (* *last-object-index* multiplier))))))


(defun convert-prop-list (prop-list)
  "Converts a statement form in an action--eg, (list 'loc ?jammer ?area)
   with no $vars to an integer key form for efficient db access."
  (iter (for item in (cdr prop-list))
        (for multiplier in '(1 1000 1000000 1000000000 1000000000000))
        (for new-item = (cond ((and (consp item) (eql (car item) 'quote))
                                 (* (gethash (second item) *constant-integers*) multiplier))
                              ((and (symbolp item)
                                    (or (char= (char (symbol-name item) 0) #\$)
                                        (char= (char (symbol-name item) 0) #\?)))
                                 `(* (gethash ,item *constant-integers*) ,multiplier))
                              ((numberp item)
                                 (* (gethash item *constant-integers*) multiplier))
                              (t (error "Error in convert-prop-list: ~A invalid in ~A"
                                        item prop-list))))
        (collect new-item into new-items)
        (finally (return (cons '+ new-items)))))
        

